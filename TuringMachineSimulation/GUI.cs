using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Windows;

namespace TuringMachineSimulation
{
    public partial class GUI : Form
    {
        TuringMachine TM;
        Pen myPen;
        Graphics g;
        List<Point> statePosition;
        enum orientation{North, South, East, West};
        public GUI()
        {
            InitializeComponent();
            TM = new TuringMachine();
            refreshTape();
            statePosition = new List<Point>(9);
            //saving the nodes locations
            statePosition.Add(new Point(150, 106));
            statePosition.Add(new Point(392, 106));
            statePosition.Add(new Point(610, 106));
            statePosition.Add(new Point(630, 283));
            statePosition.Add(new Point(309, 332));
            statePosition.Add(new Point(626, 435));
            statePosition.Add(new Point(94, 336));
            statePosition.Add(new Point(800, 114));
            statePosition.Add(new Point(793, 435));
        }

        public void refreshTape()
        {
            TapeTextBox.Text = TM.tape.getTapeState();
            TapeTextBox.SelectionStart = TM.tape.getCurrentPosition();
            TapeTextBox.SelectionLength = 1;
            TapeTextBox.SelectionColor = Color.Red;
            TapeTextBox.SelectionBackColor = Color.Yellow;
        }


        private void GraphicalTMPanel_Paint(object sender, PaintEventArgs e)
        {
            myPen = new Pen(Color.FromArgb(0, 0, 0));
            g = GraphicalTMPanel.CreateGraphics();


            myPen.Width = 3F;
            //drawing the states
            Point drawPosition;
            for (int i = 0; i < statePosition.Count; i++)
            {
                drawPosition = statePosition[i];
                drawPosition.X -= 25;
                drawPosition.Y -= 25;
                g.DrawEllipse(myPen, new Rectangle(drawPosition, new Size(50, 50)));
            }

            //drawing the labels of the nodes
            for (int i = 0; i < statePosition.Count; i++)
            {
                Label lbl = new Label();
                lbl.Size = new Size(28, 20);
                lbl.Text = "Q" + i.ToString();
                Point lblPosition = statePosition[i];
                lblPosition.X -= 10;
                lblPosition.Y -= 5;
                lbl.Location = lblPosition;
                GraphicalTMPanel.Controls.Add(lbl);
            }

            //drawing the transitions
            for (int i = 0; i < TM.states.Count; i++)
            {
                if (TM.states[i].transition.ContainsKey('0'))
                {
                    drawTransition(i, TM.states[i].transition['0'].Item3.id, '0', TM.states[i].transition['0'].Item1);
                }
                if (TM.states[i].transition.ContainsKey('1'))
                {
                    drawTransition(i, TM.states[i].transition['1'].Item3.id, '1', TM.states[i].transition['1'].Item1);
                }
                if (TM.states[i].transition.ContainsKey(' '))
                {
                    drawTransition(i, TM.states[i].transition[' '].Item3.id, ' ', TM.states[i].transition[' '].Item1);
                }
            }

        }

        void drawTransition(int fromState, int toState, char readChar, char writtenChar)
        {
            Pen curPen = new Pen(Color.FromArgb(0, 0, 0), 10F);
            curPen.EndCap = LineCap.ArrowAnchor;
            Point startLocation = statePosition[fromState];
            Point endLocation = statePosition[toState];
            double dx = endLocation.X - startLocation.X;
            double dy = endLocation.Y - startLocation.Y;
            double dist = Math.Sqrt(dx * dx + dy * dy);
            startLocation.X += (int)(25 * (Math.Sin(dx / dist)));
            startLocation.Y += (int)(25 * (Math.Sin(dy / dist)));
            endLocation.X += (int)(25 * (Math.Sin(-dx / dist)));
            endLocation.Y += (int)(25 * (Math.Sin(-dy / dist)));
            if (fromState != toState)
            {
                g.DrawLine(curPen, startLocation, endLocation);
            }
            else if (fromState != 3)
            {
                if (readChar == '0')
                {
                    drawSelfLoop(fromState, orientation.North);
                }
                else
                {
                    drawSelfLoop(fromState, orientation.South);
                }
            }
            else
            {
                drawSelfLoop(fromState, orientation.East);
            }
        }

        private void drawSelfLoop(int state, orientation or)
        {
            Pen pen = new Pen(Color.Black, 7F);
            pen.EndCap = LineCap.ArrowAnchor;
            Point location = statePosition[state];
            switch (or)
            { 
                case orientation.North:
                    location.X -= 15;
                    location.Y -= 40;
                    g.DrawArc(pen, location.X, location.Y, 40F, 40F, 180F, 200F);
                    break;

                case orientation.South:
                    location.X -= 15;
                    //location.Y += 10;
                    g.DrawArc(pen, location.X, location.Y, 40F, 40F, 180F, -200F);
                    break;

                case orientation.East:
                    //location.X += 15;
                    location.Y -= 20;
                    g.DrawArc(pen, location.X, location.Y, 40F, 40F, 260F, 200F);
                    break;
                    
                case orientation.West:
                    break;
            }
        
        }

        private void GraphicalTMPanel_Clicked(object sender, MouseEventArgs e)
        {
            //xLabel.Text = e.X.ToString();
            //yLabel.Text = e.Y.ToString();
            //SolidBrush b = new SolidBrush(Color.FromArgb(0, 0, 0));
            //g.FillEllipse(b, e.X, e.Y, 20F, 20F);
        }



    }
}
